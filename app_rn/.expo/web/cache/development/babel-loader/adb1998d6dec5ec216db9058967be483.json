{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport RNFetchBlob from 'rn-fetch-blob';\nimport RNFS, { DocumentDirectoryPath } from 'react-native-fs';\nimport { unzip as _unzip } from 'react-native-zip-archive';\nimport { DefaultPropTypes } from \"./PropTypes\";\nimport resolveAssetSource from 'react-native/Libraries/Image/resolveAssetSource';\nexport var DOCUMENTS_FOLDER = DocumentDirectoryPath + \"/rct-3d-model-view\";\nvar ACCEPTED_MODEL_TYPES = Platform.OS === 'ios' ? ['.dae', '.obj', '.scn'] : ['.dae', '.obj'];\nvar ACCEPTED_TEXTURE_TYPES = ['.png', '.jpg'];\n\nvar BaseModelView = function (_React$Component) {\n  _inherits(BaseModelView, _React$Component);\n\n  var _super = _createSuper(BaseModelView);\n\n  function BaseModelView() {\n    var _this;\n\n    _classCallCheck(this, BaseModelView);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      modelSrc: null,\n      textureSrc: null\n    };\n\n    _this.loadModel = function (props) {\n      var source = props.source,\n          onLoadModelStart = props.onLoadModelStart;\n      onLoadModelStart && onLoadModelStart();\n\n      if (source.zip) {\n        var zipSource;\n\n        if (typeof source.zip === 'string' && source.zip.startsWith('http')) {\n          zipSource = source.zip;\n        } else {\n          zipSource = resolveAssetSource(source.zip).uri;\n        }\n\n        if (zipSource) {\n          _this.fetch(zipSource).then(function (path) {\n            _this.unzip(path).then(function (src) {\n              _this.getFirstFileTypeInFolder(src, ACCEPTED_MODEL_TYPES).then(function (modelSrc) {\n                _this.setState({\n                  modelSrc: modelSrc\n                });\n              }).catch(_this.onLoadModelError);\n\n              _this.getFirstFileTypeInFolder(src, ACCEPTED_TEXTURE_TYPES).then(function (textureSrc) {\n                _this.setState({\n                  textureSrc: textureSrc\n                });\n              }).catch(_this.onLoadModelError);\n            }).catch(_this.onLoadModelError);\n          }).catch(_this.onLoadModelError);\n        }\n      } else {\n        if (source.model) {\n          var modelSource;\n\n          if (typeof source.model === 'string' && source.model.startsWith('http')) {\n            modelSource = source.model;\n          } else {\n            modelSource = resolveAssetSource(source.model).uri;\n          }\n\n          if (modelSource) {\n            _this.fetch(modelSource).then(function (modelSrc) {\n              _this.setState({\n                modelSrc: modelSrc\n              });\n            }).catch(_this.onLoadModelError);\n          }\n        }\n\n        if (source.texture) {\n          var textureSource;\n\n          if (typeof source.texture === 'string' && source.texture.startsWith('http')) {\n            textureSource = source.texture;\n          } else {\n            textureSource = resolveAssetSource(source.texture).uri;\n          }\n\n          if (textureSource) {\n            _this.fetch(textureSource).then(function (textureSrc) {\n              _this.setState({\n                textureSrc: textureSrc\n              });\n            }).catch(_this.onLoadModelError);\n          }\n        }\n      }\n    };\n\n    _this.getName = function (source) {\n      var name = source.split('/').pop();\n      name = name.includes('?') ? name.substring(0, name.indexOf('?')) : name;\n      return name;\n    };\n\n    _this.getFirstFileTypeInFolder = function (folder, acceptedFileTypes) {\n      return RNFS.readDir(folder).then(function (result) {\n        var file = result.find(function (element) {\n          for (var i = 0; i < acceptedFileTypes.length; i++) {\n            if (element.path.endsWith(acceptedFileTypes[i])) {\n              return true;\n            }\n          }\n\n          return false;\n        });\n        return file ? file.path : null;\n      });\n    };\n\n    return _this;\n  }\n\n  _createClass(BaseModelView, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.loadModel(this.props);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      if (newProps.source.zip !== this.props.source.zip || newProps.source.model !== this.props.source.model || newProps.source.texture !== this.props.source.texture) {\n        this.loadModel(newProps);\n      }\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(uri) {\n      var _this2 = this;\n\n      return RNFS.mkdir(DOCUMENTS_FOLDER).then(function () {\n        var name = _this2.getName(uri);\n\n        var targetPath = DOCUMENTS_FOLDER + \"/\" + name;\n        return RNFS.exists(targetPath).then(function (exists) {\n          if (exists) {\n            return targetPath;\n          } else {\n            return RNFetchBlob.config({\n              fileCache: true,\n              path: targetPath\n            }).fetch('GET', uri, {}).then(function (res) {\n              return res.path();\n            });\n          }\n        });\n      });\n    }\n  }, {\n    key: \"unzip\",\n    value: function unzip(path) {\n      var _this3 = this;\n\n      return _unzip(path, DOCUMENTS_FOLDER).then(function (unzippedPath) {\n        var name;\n\n        if (_this3.props.source.unzippedFolderName) {\n          name = _this3.props.source.unzippedFolderName;\n        } else {\n          name = _this3.getName(path);\n          name = name.includes('.zip') ? name.replace('.zip', '') : name;\n        }\n\n        return unzippedPath + \"/\" + name;\n      });\n    }\n  }]);\n\n  return BaseModelView;\n}(React.Component);\n\nexport default BaseModelView;","map":{"version":3,"sources":["C:/wamp64/www/expo_copie/AwesomeProject/node_modules/react-native-3d-model-view/lib/BaseModelView.js"],"names":["React","RNFetchBlob","RNFS","DocumentDirectoryPath","unzip","DefaultPropTypes","resolveAssetSource","DOCUMENTS_FOLDER","ACCEPTED_MODEL_TYPES","Platform","OS","ACCEPTED_TEXTURE_TYPES","BaseModelView","state","modelSrc","textureSrc","loadModel","props","source","onLoadModelStart","zip","zipSource","startsWith","uri","fetch","then","path","src","getFirstFileTypeInFolder","setState","catch","onLoadModelError","model","modelSource","texture","textureSource","getName","name","split","pop","includes","substring","indexOf","folder","acceptedFileTypes","readDir","result","file","find","element","i","length","endsWith","newProps","mkdir","targetPath","exists","config","fileCache","res","unzippedPath","unzippedFolderName","replace","Component"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { Platform } from 'react-native'\nimport RNFetchBlob from 'rn-fetch-blob'\nimport RNFS, { DocumentDirectoryPath } from 'react-native-fs'\nimport { unzip } from 'react-native-zip-archive'\nimport { DefaultPropTypes } from './PropTypes'\nimport resolveAssetSource from 'react-native/Libraries/Image/resolveAssetSource'\n\nexport const DOCUMENTS_FOLDER = `${DocumentDirectoryPath}/rct-3d-model-view`\n\nconst ACCEPTED_MODEL_TYPES = Platform.OS === 'ios' ? ['.dae', '.obj', '.scn'] : ['.dae', '.obj']\nconst ACCEPTED_TEXTURE_TYPES = ['.png', '.jpg']\n\nclass BaseModelView extends React.Component {\n  state = {\n    modelSrc: null,\n    textureSrc: null\n  }\n\n  componentDidMount () {\n    this.loadModel(this.props)\n  }\n\n  componentWillReceiveProps(newProps) {\n    if (newProps.source.zip !== this.props.source.zip ||\n      newProps.source.model !== this.props.source.model ||\n      newProps.source.texture !== this.props.source.texture) {\n      this.loadModel(newProps)\n    }\n  }\n\n  loadModel = (props) => {\n    const {source, onLoadModelStart} = props\n    onLoadModelStart && onLoadModelStart()\n    if (source.zip) {\n      let zipSource\n      if (typeof source.zip === 'string' && source.zip.startsWith('http')) {\n        zipSource = source.zip\n      } else {\n        zipSource = resolveAssetSource(source.zip).uri\n      }\n      if (zipSource) {\n        this.fetch(zipSource)\n        .then(path => {\n          this.unzip(path)\n          .then(src => {\n            this.getFirstFileTypeInFolder(src, ACCEPTED_MODEL_TYPES)\n            .then(modelSrc => { this.setState({modelSrc}) })\n            .catch(this.onLoadModelError)\n            this.getFirstFileTypeInFolder(src, ACCEPTED_TEXTURE_TYPES)\n            .then(textureSrc => { this.setState({textureSrc}) })\n            .catch(this.onLoadModelError)\n          })\n          .catch(this.onLoadModelError)\n        })\n        .catch(this.onLoadModelError)\n      }\n    } else {\n      if (source.model) {\n        let modelSource\n        if (typeof source.model === 'string' && source.model.startsWith('http')) {\n          modelSource = source.model\n        } else {\n          modelSource = resolveAssetSource(source.model).uri\n        }\n        if (modelSource) {\n          this.fetch(modelSource)\n          .then(modelSrc => {\n            this.setState({modelSrc})\n          })\n          .catch(this.onLoadModelError)\n        }\n      }\n      if (source.texture) {\n        let textureSource\n        if (typeof source.texture === 'string' && source.texture.startsWith('http')) {\n          textureSource = source.texture\n        } else {\n          textureSource = resolveAssetSource(source.texture).uri\n        }\n        if (textureSource) {\n          this.fetch(textureSource)\n          .then(textureSrc => {\n            this.setState({textureSrc})\n          })\n          .catch(this.onLoadModelError)\n        }\n      }\n    }\n  }\n\n  fetch (uri) {\n    return RNFS.mkdir(DOCUMENTS_FOLDER)\n    .then(() => {\n      const name = this.getName(uri)\n      const targetPath = `${DOCUMENTS_FOLDER}/${name}`\n      return RNFS.exists(targetPath)\n      .then(exists => {\n        if (exists) {\n          return targetPath\n        } else {\n          return RNFetchBlob\n          .config({\n            fileCache: true,\n            path: targetPath\n          })\n          .fetch('GET', uri, {})\n          .then(res => res.path())\n        }\n      })\n    })\n  }\n\n  unzip (path) {\n    return unzip(path, DOCUMENTS_FOLDER)\n    .then(unzippedPath => {\n      let name\n      if (this.props.source.unzippedFolderName) {\n        name = this.props.source.unzippedFolderName\n      } else {\n        name = this.getName(path)\n        name = name.includes('.zip') ? name.replace('.zip', '') : name\n      }\n      return `${unzippedPath}/${name}`\n    })\n  }\n\n  getName = (source) => {\n    let name = source.split('/').pop()\n    name = name.includes('?') ? name.substring(0, name.indexOf('?')) : name\n    return name\n  }\n\n  getFirstFileTypeInFolder = (folder, acceptedFileTypes) => {\n    return RNFS.readDir(folder)\n    .then((result) => {\n      const file = result.find(element => {\n        for (let i = 0; i < acceptedFileTypes.length; i++) {\n          if (element.path.endsWith(acceptedFileTypes[i])) {\n            return true\n          }\n        }\n        return false\n      })\n      return file ? file.path : null\n    })\n  }\n}\n\nexport default BaseModelView\n"]},"metadata":{},"sourceType":"module"}